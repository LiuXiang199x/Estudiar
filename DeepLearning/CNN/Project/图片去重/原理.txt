
=================== 感知哈希算法 ============================
一张图片就是一个二维信号，它包含了不同频率的成分。
亮度变化小的区域是低频成分，它描述大范围的信息。
而亮度变化剧烈的区域（比如物体的边缘）就是高频的成分，它描述具体的细节。
或者说高频可以提供图片详细的信息，而低频可以提供一个框架。

而一张大的，详细的图片有很高的频率，而小图片缺乏图像细节，所以都是低频的。
所以我们平时的下采样，也就是缩小图片的过程，实际上是损失高频信息的过程。

均值哈希算法主要是利用图片的低频信息，其工作过程如下：
（1）缩小尺寸：去除高频和细节的最快方法是缩小图片，将图片缩小到8x8的尺寸，总共64个像素。
不要保持纵横比，只需将其变成8*8的正方形。这样就可以比较任意大小的图片，摒弃不同尺寸、比例带来的图片差异。
（2）简化色彩：将8*8的小图片转换成灰度图像。
（3）计算平均值：计算所有64个像素的灰度平均值。
（4）比较像素的灰度：将每个像素的灰度，与平均值进行比较。
大于或等于平均值，记为1；小于平均值，记为0。
（5）计算hash值：将上一步的比较结果，组合在一起，就构成了一个64位的整数，这就是这张图片的指纹。
组合的次序并不重要，只要保证所有图片都采用同样次序就行了。(我设置的是从左到右，从上到下用二进制保存)。


计算一个图片的hash指纹的过程就是这么简单。刚开始的时候觉得这样就损失了图片的很多信息了，居然还能有效。
简单的算法也许存在另一种美。如果图片放大或缩小，或改变纵横比，结果值也不会改变。
增加或减少亮度或对比度，或改变颜色，对hash值都不会太大的影响。最大的优点：计算速度快！

这时候，比较两个图片的相似性，就是先计算这两张图片的hash指纹，也就是64位0或1值，然后计算不同位的个数(汉明距离)。
如果这个值为0，则表示这两张图片非常相似，如果汉明距离小于5，则表示有些不同，但比较相近，如果汉明距离大于10则表明完全不同的图片。

=========================== 增强版：pHash =======================

均值哈希虽然简单，但受均值的影响非常大。例如对图像进行伽马校正或直方图均衡就会影响均值，从而影响最终的hash值。
存在一个更健壮的算法叫pHash。它将均值的方法发挥到极致。使用离散余弦变换(DCT)来获取图片的低频成分。

离散余弦变换（DCT）是种图像压缩算法，它将图像从像素域变换到频率域。
然后一般图像都存在很多冗余和相关性的，所以转换到频率域之后，只有很少的一部分频率分量的系数才不为0，大部分系数都为0（或者说接近于0）。
下图的右图是对lena图进行离散余弦变换（DCT）得到的系数矩阵图。从左上角依次到右下角，频率越来越高，由图可以看到，左上角的值比较大，到右下角的值就很小很小了。
(https://img-blog.csdn.net/20131221201455125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvem91eHkwOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
换句话说，图像的能量几乎都集中在左上角这个地方的低频系数上面了。

pHash的工作过程如下：
（1）缩小尺寸：pHash以小图片开始，但图片大于8*8，32*32是最好的。这样做的目的是简化了DCT的计算，而不是减小频率。
（2）简化色彩：将图片转化成灰度图像，进一步简化计算量。
（3）计算DCT：计算图片的DCT变换，得到32*32的DCT系数矩阵。
（4）缩小DCT：虽然DCT的结果是32*32大小的矩阵，但我们只要保留左上角的8*8的矩阵，这部分呈现了图片中的最低频率。
（5）计算平均值：如同均值哈希一样，计算DCT的均值。
（6）计算hash值：这是最主要的一步，根据8*8的DCT矩阵，设置0或1的64位的hash值，大于等于DCT均值的设为”1”，小于DCT均值的设为“0”。组合在一起，就构成了一个64位的整数，这就是这张图片的指纹。

结果并不能告诉我们真实性的低频率，只能粗略地告诉我们相对于平均值频率的相对比例。
只要图片的整体结构保持不变，hash结果值就不变。能够避免伽马校正或颜色直方图被调整带来的影响。

与均值哈希一样，pHash同样可以用汉明距离来进行比较。(只需要比较每一位对应的位置并算计不同的位的个数)